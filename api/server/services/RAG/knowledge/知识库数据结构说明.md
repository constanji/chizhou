# 知识库数据结构说明

## 概述

知识库数据同时存储在两种数据库中：

1. **MongoDB** (`KnowledgeEntry` 集合) - 存储完整的信息，包括元数据和向量
2. **PostgreSQL + pgvector** (`knowledge_vectors` 表) - 专门用于高效的向量相似度搜索

## MongoDB 数据结构

### KnowledgeEntry 集合

**集合名称**: `knowledgeentries`

**Schema 定义**:

```typescript
{
  user: ObjectId,              // 用户ID，关联到User集合
  type: String,                // 知识类型（见下方类型说明）
  title: String,               // 标题
  content: String,             // 内容文本
  embedding: [Number],         // 向量嵌入（384维）
  metadata: {
    // 语义模型相关字段
    semantic_model_id?: String,
    database_name?: String,
    table_name?: String,
    
    // QA对相关字段
    question?: String,
    answer?: String,
    
    // 同义词相关字段
    noun?: String,
    synonyms?: [String],
    
    // 业务知识相关字段
    category?: String,
    tags?: [String],
    
    // 文件相关字段（兼容现有）
    file_id?: String,
    filename?: String,
    page?: Number,
    chunk_index?: Number,
    
    // 通用字段
    source?: String,
    entity_id?: String,
    [key: string]: any         // 其他自定义字段
  },
  createdAt: Date,             // 创建时间
  updatedAt: Date              // 更新时间
}
```

### 索引

```javascript
// 用户和类型联合索引
{ user: 1, type: 1 }

// 文件ID索引
{ 'metadata.file_id': 1 }

// 语义模型ID索引
{ 'metadata.semantic_model_id': 1 }

// 实体ID索引
{ 'metadata.entity_id': 1 }

// 创建时间索引（降序）
{ createdAt: -1 }
```

## PostgreSQL 向量数据库结构

### knowledge_vectors 表

**表名**: `knowledge_vectors`

**表结构**:

```sql
CREATE TABLE knowledge_vectors (
  id SERIAL PRIMARY KEY,                        -- 自增主键
  knowledge_entry_id VARCHAR(255) UNIQUE NOT NULL, -- 对应MongoDB的_id
  user_id VARCHAR(255) NOT NULL,               -- 用户ID
  type VARCHAR(50) NOT NULL,                   -- 知识类型
  content TEXT NOT NULL,                       -- 内容文本
  embedding vector(384),                       -- BGE模型的384维向量
  metadata JSONB DEFAULT '{}'::jsonb,          -- JSON格式的元数据
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**索引**:

```sql
-- 用户和类型联合索引
CREATE INDEX idx_knowledge_vectors_user_type 
ON knowledge_vectors(user_id, type);

-- HNSW向量相似度搜索索引（核心性能优化）
CREATE INDEX idx_knowledge_vectors_embedding_hnsw 
ON knowledge_vectors 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

## 知识类型说明

### 1. 语义模型 (semantic_model)

用于存储数据库表的语义模型信息。

**MongoDB 示例**:

```json
{
  "_id": ObjectId("..."),
  "user": ObjectId("user123"),
  "type": "semantic_model",
  "title": "语义模型: mall_demo.orders",
  "content": "{\"table\":\"orders\",\"columns\":[{\"name\":\"order_id\",\"type\":\"int\",\"description\":\"订单ID\"}]}",
  "embedding": [0.1, 0.2, 0.3, ...], // 384维向量
  "metadata": {
    "semantic_model_id": "model_001",
    "database_name": "mall_demo",
    "table_name": "orders",
    "entity_id": "entity_123"
  },
  "createdAt": ISODate("2024-01-01T00:00:00Z"),
  "updatedAt": ISODate("2024-01-01T00:00:00Z")
}
```

**PostgreSQL 示例**:

```sql
INSERT INTO knowledge_vectors (
  knowledge_entry_id,
  user_id,
  type,
  content,
  embedding,
  metadata
) VALUES (
  '507f1f77bcf86cd799439011',
  'user123',
  'semantic_model',
  '{"table":"orders","columns":[...]}',
  '[0.1, 0.2, 0.3, ...]'::vector,
  '{
    "semantic_model_id": "model_001",
    "database_name": "mall_demo",
    "table_name": "orders",
    "entity_id": "entity_123"
  }'::jsonb
);
```

### 2. QA对 (qa_pair)

用于存储问答对。

**MongoDB 示例**:

```json
{
  "_id": ObjectId("..."),
  "user": ObjectId("user123"),
  "type": "qa_pair",
  "title": "QA: 什么是RAG？",
  "content": "问题: 什么是RAG？\n答案: RAG是检索增强生成技术",
  "embedding": [0.1, 0.2, 0.3, ...], // 384维向量（基于问题生成）
  "metadata": {
    "question": "什么是RAG？",
    "answer": "RAG是检索增强生成技术",
    "entity_id": "entity_123"
  },
  "createdAt": ISODate("2024-01-01T00:00:00Z"),
  "updatedAt": ISODate("2024-01-01T00:00:00Z")
}
```

**PostgreSQL 示例**:

```sql
INSERT INTO knowledge_vectors (
  knowledge_entry_id,
  user_id,
  type,
  content,
  embedding,
  metadata
) VALUES (
  '507f1f77bcf86cd799439012',
  'user123',
  'qa_pair',
  '问题: 什么是RAG？\n答案: RAG是检索增强生成技术',
  '[0.1, 0.2, 0.3, ...]'::vector,
  '{
    "question": "什么是RAG？",
    "answer": "RAG是检索增强生成技术",
    "entity_id": "entity_123"
  }'::jsonb
);
```

### 3. 同义词 (synonym)

用于存储名词及其同义词映射。

**MongoDB 示例**:

```json
{
  "_id": ObjectId("..."),
  "user": ObjectId("user123"),
  "type": "synonym",
  "title": "同义词: 订单",
  "content": "名词: 订单\n同义词: 订购, 下单, 购买",
  "embedding": [0.1, 0.2, 0.3, ...], // 384维向量（基于名词和同义词生成）
  "metadata": {
    "noun": "订单",
    "synonyms": ["订购", "下单", "购买"],
    "entity_id": "entity_123"
  },
  "createdAt": ISODate("2024-01-01T00:00:00Z"),
  "updatedAt": ISODate("2024-01-01T00:00:00Z")
}
```

**PostgreSQL 示例**:

```sql
INSERT INTO knowledge_vectors (
  knowledge_entry_id,
  user_id,
  type,
  content,
  embedding,
  metadata
) VALUES (
  '507f1f77bcf86cd799439013',
  'user123',
  'synonym',
  '名词: 订单\n同义词: 订购, 下单, 购买',
  '[0.1, 0.2, 0.3, ...]'::vector,
  '{
    "noun": "订单",
    "synonyms": ["订购", "下单", "购买"],
    "entity_id": "entity_123"
  }'::jsonb
);
```

### 4. 业务知识 (business_knowledge)

用于存储业务相关的知识文档。

**MongoDB 示例**:

```json
{
  "_id": ObjectId("..."),
  "user": ObjectId("user123"),
  "type": "business_knowledge",
  "title": "订单处理流程",
  "content": "订单处理流程包括：1. 接收订单 2. 验证库存 3. 处理支付 4. 发货",
  "embedding": [0.1, 0.2, 0.3, ...], // 384维向量（基于内容生成）
  "metadata": {
    "category": "流程说明",
    "tags": ["订单", "流程", "业务"],
    "entity_id": "entity_123"
  },
  "createdAt": ISODate("2024-01-01T00:00:00Z"),
  "updatedAt": ISODate("2024-01-01T00:00:00Z")
}
```

**PostgreSQL 示例**:

```sql
INSERT INTO knowledge_vectors (
  knowledge_entry_id,
  user_id,
  type,
  content,
  embedding,
  metadata
) VALUES (
  '507f1f77bcf86cd799439014',
  'user123',
  'business_knowledge',
  '订单处理流程包括：1. 接收订单 2. 验证库存 3. 处理支付 4. 发货',
  '[0.1, 0.2, 0.3, ...]'::vector,
  '{
    "category": "流程说明",
    "tags": ["订单", "流程", "业务"],
    "entity_id": "entity_123"
  }'::jsonb
);
```

### 5. 文件 (file)

用于存储文件的向量化内容（兼容现有功能）。

**MongoDB 示例**:

```json
{
  "_id": ObjectId("..."),
  "user": ObjectId("user123"),
  "type": "file",
  "title": "文档.pdf",
  "content": "文档的文本内容片段...",
  "embedding": [0.1, 0.2, 0.3, ...], // 384维向量
  "metadata": {
    "file_id": "file_123",
    "filename": "文档.pdf",
    "page": 1,
    "chunk_index": 0,
    "entity_id": "entity_123"
  },
  "createdAt": ISODate("2024-01-01T00:00:00Z"),
  "updatedAt": ISODate("2024-01-01T00:00:00Z")
}
```

## 数据关系

### MongoDB 与 PostgreSQL 的关联

- **MongoDB 的 `_id`** ↔ **PostgreSQL 的 `knowledge_entry_id`**
- 两个数据库通过 `knowledge_entry_id` 字段关联
- 写入时同时写入两个数据库
- 查询时优先使用 PostgreSQL 的向量搜索，然后从 MongoDB 获取完整信息

### 数据同步机制

```javascript
// 1. 写入 MongoDB
const knowledgeEntry = new KnowledgeEntry({...});
await knowledgeEntry.save();

// 2. 同时写入 PostgreSQL
await vectorDBService.storeKnowledgeVector({
  knowledgeEntryId: knowledgeEntry._id.toString(),
  userId: userId.toString(),
  type: knowledgeEntry.type,
  content: knowledgeEntry.content,
  embedding: knowledgeEntry.embedding,
  metadata: knowledgeEntry.metadata,
});
```

## 向量嵌入说明

### 向量维度

- **维度**: 384 (BGE Small 模型)
- **类型**: Float32 数组
- **归一化**: 向量已归一化（L2范数为1）

### 向量生成规则

1. **语义模型**: 基于语义模型的 JSON 字符串内容生成
2. **QA对**: 基于**问题**文本生成（用于搜索匹配）
3. **同义词**: 基于"名词 + 同义词"的组合文本生成
4. **业务知识**: 基于知识内容的全文生成
5. **文件**: 基于文件片段内容生成

### 示例向量

```javascript
// 384维向量示例（已归一化）
embedding: [
  0.0234, -0.0156, 0.0892, 0.0123, -0.0456, 
  0.0789, 0.0345, -0.0567, 0.0987, 0.0012,
  // ... 共384个数值
]
```

## 查询示例

### MongoDB 查询

```javascript
// 查询用户的语义模型
const semanticModels = await KnowledgeEntry.find({
  user: userId,
  type: 'semantic_model',
  'metadata.database_name': 'mall_demo'
});

// 查询用户的QA对
const qaPairs = await KnowledgeEntry.find({
  user: userId,
  type: 'qa_pair',
  'metadata.entity_id': entityId
});
```

### PostgreSQL 向量搜索

```sql
-- 相似度搜索（余弦相似度）
SELECT 
  knowledge_entry_id,
  content,
  1 - (embedding <=> $1::vector) as similarity
FROM knowledge_vectors
WHERE user_id = 'user123'
  AND type = 'qa_pair'
  AND 1 - (embedding <=> $1::vector) >= 0.5
ORDER BY embedding <=> $1::vector
LIMIT 10;
```

### 混合查询（推荐）

```javascript
// 1. 使用 PostgreSQL 进行向量搜索（高效）
const vectorResults = await vectorDBService.searchSimilar({
  queryEmbedding: queryVector,
  userId: userId,
  types: ['qa_pair'],
  topK: 10,
});

// 2. 从 MongoDB 获取完整信息
const ids = vectorResults.map(r => r.knowledgeEntryId);
const fullEntries = await KnowledgeEntry.find({
  _id: { $in: ids }
});
```

## 数据量估算

### 单条记录大小

- **MongoDB**: 约 1-5 KB（取决于内容和元数据）
- **PostgreSQL**: 约 2-6 KB（包括向量约1.5 KB）

### 索引大小

- **MongoDB 索引**: 每个索引约每条记录 100-200 bytes
- **PostgreSQL HNSW 索引**: 每个向量约 500-1000 bytes

### 存储建议

- **小规模** (< 10,000 条): 两个数据库都可以
- **中等规模** (10,000 - 100,000 条): 推荐使用 PostgreSQL 向量搜索
- **大规模** (> 100,000 条): 必须使用 PostgreSQL + HNSW 索引

## 数据迁移

### 从 MongoDB 迁移到 PostgreSQL

```javascript
// 迁移脚本示例
const entries = await KnowledgeEntry.find({});
for (const entry of entries) {
  await vectorDBService.storeKnowledgeVector({
    knowledgeEntryId: entry._id.toString(),
    userId: entry.user.toString(),
    type: entry.type,
    content: entry.content,
    embedding: entry.embedding,
    metadata: entry.metadata || {},
  });
}
```

## 数据备份

### MongoDB 备份

```bash
mongodump --db BecauseAi --collection knowledgeentries --out backup/
```

### PostgreSQL 备份

```bash
docker exec Because-VectorDB pg_dump -U myuser mydatabase > backup.sql
```

## 数据清理

### 删除用户的所有知识条目

```javascript
// MongoDB
await KnowledgeEntry.deleteMany({ user: userId });

// PostgreSQL
await pool.query('DELETE FROM knowledge_vectors WHERE user_id = $1', [userId]);
```

### 清理过期数据

```javascript
// 删除30天前的数据
const cutoffDate = new Date();
cutoffDate.setDate(cutoffDate.getDate() - 30);

await KnowledgeEntry.deleteMany({
  createdAt: { $lt: cutoffDate }
});
```

## 性能优化建议

1. **使用 PostgreSQL 向量搜索**: 对于相似度搜索，优先使用 PostgreSQL
2. **合理使用索引**: MongoDB 和 PostgreSQL 都已创建必要的索引
3. **批量操作**: 对于大量数据，使用批量插入
4. **连接池**: PostgreSQL 使用连接池管理连接
5. **定期维护**: 定期执行 VACUUM 和 ANALYZE（PostgreSQL）

## 相关文件

- **MongoDB Schema**: `packages/data-schemas/src/schema/knowledgeBase.ts`
- **PostgreSQL Schema**: `api/server/services/RAG/VectorDBService.js` (ensureTables方法)
- **服务实现**: `api/server/services/RAG/KnowledgeBaseService.js`

